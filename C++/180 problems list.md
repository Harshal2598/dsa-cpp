ğŸ§© CATEGORY-WISE 180 PROBLEMS (WITH DIFFICULTY + PATTERN)
ğŸŸ¦ 1. ARRAYS (25)

Two Sum â€“ Easy â€“ HashMap / Pair Sum

Best Time to Buy and Sell Stock â€“ Easy/Med â€“ Single-pass / Prefix min

Maximum Subarray (Kadaneâ€™s) â€“ Medium â€“ 1D DP / Kadane

Merge Intervals â€“ Medium â€“ Sorting + Interval

Insert Interval â€“ Medium â€“ Interval + Edge cases

Sort Colors (Dutch Flag) â€“ Medium â€“ 3-pointer / Partition

Rotate Array â€“ Easy â€“ Reverse trick / rotation

Remove Duplicates from Sorted Array â€“ Easy â€“ Two pointers

Maximum Product Subarray â€“ Medium â€“ 1D DP (max/min tracking)

Next Permutation â€“ Medium â€“ Array manipulation / permutations

Set Matrix Zeroes â€“ Medium â€“ Matrix marking

Spiral Matrix â€“ Medium â€“ Matrix traversal

Jump Game â€“ Medium â€“ Greedy

Majority Element â€“ Easy â€“ Boyerâ€“Moore / frequency

Majority Element II â€“ Medium â€“ Extended Boyerâ€“Moore

Container With Most Water â€“ Medium â€“ Two pointers

Trapping Rain Water â€“ Hard â€“ Two pointers / prefix max

Merge Sorted Array â€“ Easy â€“ Two pointers (from end)

Subarray Sum Equals K â€“ Medium â€“ Prefix sum + HashMap

Longest Consecutive Sequence â€“ Medium â€“ HashSet

Find Minimum in Rotated Sorted Array â€“ Medium â€“ Binary search (rotated)

Search in Rotated Sorted Array â€“ Medium â€“ Binary search (rotated)

3Sum â€“ Medium â€“ Sorting + two pointers

4Sum â€“ Medium/Hard â€“ Sorting + two pointers + pruning

Product of Array Except Self â€“ Medium â€“ Prefix + suffix multiplication

ğŸŸ¦ 2. STRINGS (20)

Valid Anagram â€“ Easy â€“ HashMap / frequency

Valid Palindrome â€“ Easy â€“ Two pointers

Longest Common Prefix â€“ Easy â€“ Prefix scan

Reverse Words in a String â€“ Medium â€“ String parsing

Longest Substring Without Repeating Characters â€“ Medium â€“ Sliding window

Longest Palindromic Substring â€“ Medium â€“ Expand around center / DP

Count Palindromic Substrings â€“ Medium â€“ Expand around center

Group Anagrams â€“ Medium â€“ HashMap (signature)

String Compression â€“ Easy/Med â€“ Two pointers / in-place

Minimum Window Substring â€“ Hard â€“ Sliding window

Implement strStr() / KMP â€“ Medium â€“ String matching

Add Binary â€“ Easy â€“ Binary addition / strings

Decode Ways â€“ Medium â€“ DP on string

Integer to Roman â€“ Medium â€“ Greedy mapping

Roman to Integer â€“ Easy â€“ Parsing + mapping

Multiply Strings â€“ Medium â€“ Simulated multiplication

Isomorphic Strings â€“ Easy/Med â€“ HashMap mapping

Remove All Adjacent Duplicates in String â€“ Easy â€“ Stack / two pointer

Custom Sort String â€“ Medium â€“ Counting + order map

Valid Parentheses â€“ Easy â€“ Stack

ğŸŸ¦ 3. HASHMAP / SET FOCUSED (10)

Two Sum (single-pass map version) â€“ Easy â€“ HashMap

Subarray Sum Equals K â€“ Medium â€“ Prefix + HashMap

Longest Consecutive Sequence â€“ Medium â€“ HashSet

Happy Number â€“ Easy â€“ Set + Floyd cycle

Ransom Note â€“ Easy â€“ Frequency map

Word Pattern â€“ Easy/Med â€“ Bi-map

Top K Frequent Elements â€“ Medium â€“ HashMap + Heap

Longest Harmonious Subsequence â€“ Easy/Med â€“ Frequency map

First Unique Character in a String â€“ Easy â€“ Frequency

Group Shifted Strings â€“ Medium â€“ Hash map on pattern

ğŸŸ¦ 4. SLIDING WINDOW (10)

Maximum Sum Subarray of Size K (fixed window) â€“ Easy â€“ Sliding window

Longest Substring Without Repeating Characters â€“ Medium â€“ Sliding window + Set

Minimum Window Substring â€“ Hard â€“ Sliding window + counts

Fruit Into Baskets â€“ Medium â€“ At-most-2 distinct window

Longest Repeating Character Replacement â€“ Medium â€“ Window + max freq

Binary Subarray With Sum â€“ Medium â€“ Prefix/window

Count Occurrences of Anagrams â€“ Medium â€“ Sliding window + frequency

Sliding Window Maximum â€“ Hard â€“ Deque / monotonic queue

Max Consecutive Ones III â€“ Medium â€“ Window with allowed flips

Partition Labels â€“ Medium â€“ Greedy + last occurrence

ğŸŸ¦ 5. TWO POINTERS (10)

Valid Palindrome II â€“ Easy/Med â€“ Two pointers with one removal

Remove Duplicates from Sorted Array â€“ Easy â€“ Two pointers

Move Zeroes â€“ Easy â€“ Two pointers / stable

Sort Colors â€“ Medium â€“ 3-pointer (Dutch flag)

3Sum â€“ Medium â€“ Sort + two pointers

4Sum â€“ Medium â€“ Sort + two pointers + pruning

Container With Most Water â€“ Medium â€“ Two pointers

Backspace String Compare â€“ Easy/Med â€“ Two pointers backwards

Linked List Cycle (Floydâ€™s) â€“ Easy/Med â€“ Fast/slow pointers

Compare Version Numbers â€“ Medium â€“ Pointer parsing

ğŸŸ¦ 6. LINKED LIST (10)

Reverse Linked List â€“ Easy â€“ Iterative reversal

Merge Two Sorted Lists â€“ Easy â€“ Merge

Linked List Cycle â€“ Easy/Med â€“ Floydâ€™s

Remove Nth Node From End â€“ Medium â€“ Two pointers

Add Two Numbers â€“ Medium â€“ Simulated addition via list

Intersection of Two Linked Lists â€“ Easy/Med â€“ Length difference trick

Reorder List â€“ Medium â€“ Split + reverse + merge

Middle of the Linked List â€“ Easy â€“ Fast/slow pointers

Copy List with Random Pointer â€“ Medium â€“ HashMap / in-place trick

Flatten a Multilevel Doubly Linked List â€“ Medium â€“ DFS

ğŸŸ¦ 7. STACK & QUEUE (10)

Valid Parentheses â€“ Easy â€“ Stack

Min Stack â€“ Medium â€“ Two stacks

Daily Temperatures â€“ Medium â€“ Monotonic stack

Next Greater Element I/II â€“ Medium â€“ Monotonic stack

Evaluate Reverse Polish Notation â€“ Medium â€“ Stack eval

Sliding Window Maximum â€“ Hard â€“ Deque

Basic Calculator II (or I) â€“ Medium/Hard â€“ Stack/infix eval

Decode String â€“ Medium â€“ Stack-based expansion

Simplify Path â€“ Medium â€“ Stack on path components

Implement Queue Using Stacks â€“ Easy/Med â€“ Stack trick

ğŸŸ¦ 8. BINARY SEARCH (10)

Classic Binary Search â€“ Easy â€“ BS template

Search Insert Position â€“ Easy â€“ Lower_bound

Find First and Last Position of Element â€“ Medium â€“ Bound search

Search in Rotated Sorted Array â€“ Medium â€“ BS + rotation logic

Find Minimum in Rotated Sorted Array â€“ Medium â€“ Rotated BS

Peak Element â€“ Medium â€“ Binary search on slopes

Koko Eating Bananas â€“ Medium â€“ BS on answer

Median of Two Sorted Arrays â€“ Hard â€“ BS partition

Allocate Books / Split Array Largest Sum â€“ Hard â€“ BS on answer

Sqrt(x) â€“ Easy â€“ Integer binary search

ğŸŸ¦ 9. RECURSION / BACKTRACKING (10)

Subsets â€“ Medium â€“ Backtracking / powerset

Permutations â€“ Medium â€“ Backtracking

Combination Sum â€“ Medium â€“ Backtracking with reuse

Combination Sum II â€“ Medium â€“ Backtracking with duplicate handling

Word Search â€“ Medium â€“ DFS backtracking on grid

N-Queens â€“ Hard â€“ Backtracking with constraints

Sudoku Solver â€“ Hard â€“ Backtracking search

Generate Parentheses â€“ Medium â€“ Backtracking with constraints

Letter Combinations of a Phone Number â€“ Medium â€“ Backtracking

Rat in a Maze / Maze Pathfinding â€“ Medium â€“ Backtracking on grid

ğŸŸ¦ 10. TREES (15)

Binary Tree Inorder Traversal â€“ Easy â€“ DFS / iterative

Preorder Traversal â€“ Easy

Postorder Traversal â€“ Easy/Med

Level Order Traversal â€“ Easy â€“ BFS

Zigzag Level Order Traversal â€“ Medium â€“ BFS + flag

Height / Max Depth of Binary Tree â€“ Easy â€“ DFS

Balanced Binary Tree â€“ Easy/Med â€“ DFS with height

Diameter of Binary Tree â€“ Medium â€“ DFS with longest path

Right Side View â€“ Medium â€“ BFS / DFS

Left View â€“ Medium

Path Sum I/II â€“ Medium â€“ DFS + sum tracking

Lowest Common Ancestor of BST â€“ Easy/Med â€“ BST logic

Lowest Common Ancestor of Binary Tree â€“ Medium â€“ DFS

Serialize and Deserialize Binary Tree â€“ Hard â€“ BFS/DFS

Kth Smallest Element in a BST â€“ Medium â€“ Inorder

ğŸŸ¦ 11. GRAPHS (10)

Number of Islands â€“ Medium â€“ DFS/BFS on grid

Clone Graph â€“ Medium â€“ DFS/BFS + map

BFS Traversal of Graph â€“ Easy â€“ BFS template

DFS Traversal of Graph â€“ Easy/Med â€“ DFS template

Rotting Oranges â€“ Medium â€“ Multi-source BFS

Course Schedule â€“ Medium â€“ Topological sort / cycle detect

Course Schedule II â€“ Medium â€“ Topological ordering

Shortest Path in Weighted Graph (Dijkstra) â€“ Medium/Hard â€“ Priority queue

Word Ladder â€“ Hard â€“ BFS on word graph

Detect Cycle in Graph (Directed/Undirected) â€“ Medium â€“ DFS/DSU

ğŸŸ¦ 12. HEAP / PRIORITY QUEUE (10)

Kth Largest Element in an Array â€“ Medium â€“ Heap / quickselect

Merge K Sorted Lists â€“ Hard â€“ Min-heap

Reorganize String â€“ Medium â€“ Max-heap on counts

Top K Frequent Words / Elements â€“ Medium â€“ Map + heap

Find Median from Data Stream â€“ Hard â€“ Two heaps

IPO Problem / Maximize Capital â€“ Hard â€“ Two heaps

Meeting Rooms II â€“ Medium â€“ Min-heap on end times

Task Scheduler â€“ Medium â€“ Greedy + frequency / heap

K Closest Points to Origin â€“ Medium â€“ Heap or sort

Sliding Window Maximum â€“ Hard â€“ Heap/Deque

ğŸŸ¦ 13. DYNAMIC PROGRAMMING (15)

Climbing Stairs â€“ Easy â€“ 1D DP (Fibonacci)

House Robber â€“ Medium â€“ 1D DP

House Robber II â€“ Medium â€“ Circular DP

Coin Change â€“ Medium â€“ Unbounded knapsack style DP

Longest Increasing Subsequence â€“ Medium/Hard â€“ DP or binary search

Maximum Product Subarray â€“ Medium â€“ DP with min/max

Longest Common Subsequence â€“ Medium â€“ 2D DP

Edit Distance â€“ Hard â€“ 2D DP

Partition Equal Subset Sum â€“ Medium â€“ Subset-sum DP

0/1 Knapsack â€“ Medium â€“ Classic DP

Minimum Path Sum â€“ Medium â€“ Grid DP

Unique Paths â€“ Medium â€“ Combinatorics/DP

Jump Game II â€“ Medium â€“ Greedy/DP

Rod Cutting â€“ Medium â€“ Unbounded knapsack variant

Longest Palindromic Subsequence â€“ Medium â€“ 2D DP

ğŸŸ¦ 14. â€œOTHER / MISC / CLEANUPâ€ (15 left for 180)

We already have 165 above â†’ last ~15 are mostly variants / extra important repeats from arrays/strings/graphs/bit:

Power of Two â€“ Easy â€“ Bit manipulation

Number of 1 Bits â€“ Easy â€“ Bit operations

Reverse Bits â€“ Easy/Med â€“ Bit ops

Single Number â€“ Easy â€“ XOR

Subsets II â€“ Medium â€“ Backtracking with duplicates

Binary Tree Maximum Path Sum â€“ Hard â€“ DFS + DP

Gas Station â€“ Medium â€“ Greedy

Insert Delete GetRandom O(1) â€“ Medium â€“ HashMap + array

LRU Cache â€“ Medium/Hard â€“ LinkedHashMap / DLL + map

Implement Trie (Prefix Tree) â€“ Medium â€“ Trie

Design HashMap / HashSet â€“ Easy/Med â€“ Basic DS

Random Pick with Weight â€“ Medium â€“ Prefix sums

Search a 2D Matrix â€“ Medium â€“ Matrix + binary search

Number of Islands II / DSU variation â€“ Hard â€“ Union-Find

Topological Sort (template) â€“ Medium â€“ Kahnâ€™s / DFS

ğŸ§­ PATTERN â†’ COMPANIES MAP (10 PER PATTERN)

These are pattern-level, not per-problem, which matches what companies actually do.

ğŸ”¹ Sliding Window (Substring, subarray, min/max windows)

Companies: Amazon, Microsoft, Meta, Google, Netflix, Uber, Adobe, Atlassian, Bloomberg, PayPal

ğŸ”¹ Two Pointers (arrays, strings, palindromes)

Companies: Amazon, Google, Microsoft, Apple, Meta, LinkedIn, Uber, Airbnb, Goldman Sachs, Morgan Stanley

ğŸ”¹ HashMap / HashSet / Frequency

Companies: Amazon, Meta, Microsoft, Google, Apple, Netflix, Uber, Paytm, Flipkart, Swiggy

ğŸ”¹ Binary Search (incl. â€œsearch on answerâ€)

Companies: Google, Facebook/Meta, Microsoft, Amazon, Bloomberg, Jane Street, Adobe, Uber, DoorDash, Databricks

ğŸ”¹ Recursion / Backtracking (Subsets, N-Queens, Sudoku)

Companies: Google, Meta, Microsoft, Adobe, Atlassian, Uber, Airbnb, Dropbox, Salesforce, SAP

ğŸ”¹ Trees (DFS/BFS/LCA/Views)

Companies: Google, Amazon, Microsoft, Meta, Apple, Bloomberg, Oracle, SAP, Infosys, TCS Digital

ğŸ”¹ Graphs (BFS, DFS, Topo, Shortest Path)

Companies: Google, Facebook, Microsoft, Amazon, Uber, Lyft, Airbnb, Palantir, Snowflake, Nvidia

ğŸ”¹ Dynamic Programming

Companies: Google, Meta, Amazon, Microsoft, Apple, Bloomberg, Salesforce, Goldman Sachs, Morgan Stanley, Expedia

ğŸ”¹ Heap / Priority Queue

Companies: Amazon, Uber, Google, Bloomberg, Goldman Sachs, Morgan Stanley, Facebook, Microsoft, DoorDash, Swiggy

ğŸ”¹ Stack / Monotonic Structures

Companies: Amazon, Google, Meta, Microsoft, Netflix, Adobe, Uber, Oracle, Cisco, PayPal

ğŸ”¹ Tries / Prefix Trees

Companies: Google (search, autocomplete), Microsoft, Amazon, Meta, Apple, Baidu, Alibaba, Yandex, DuckDuckGo, Bloomberg

ğŸ“’ HOW TO TURN THIS INTO NOTES

For each problem, in your DSA GitHub repo or MCA notes, make a template like:

# Problem: Two Sum
- Category: Array / HashMap
- Difficulty: Easy
- Pattern: HashMap (pair sum)

## Why companies ask this
- Tests basic hashing & thinking in O(n)
- Very common subpattern in harder questions

## Approach (in my words)
1. Create a HashMap<value, index>
2. For each element x, check if (target - x) exists in map
3. If yes â†’ return indices
4. Else â†’ insert x into map

## Time: O(n)
## Space: O(n)

## Variations I know
- Return count of pairs
- K-sum using same pattern


Do this for every problem you solve, not all 180 at once. Build it gradually.
